(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{382:function(t,e,a){"use strict";a.r(e);var s=a(41),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"循环依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环依赖","aria-hidden":"true"}},[t._v("#")]),t._v(" 循环依赖")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/inversify/InversifyJS/blob/master/wiki/circular_dependencies.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("原文链接"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"模块的循环依赖-es6、commonjs等等"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块的循环依赖-es6、commonjs等等","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块的循环依赖(ES6、CommonJS等等)")]),t._v(" "),a("p",[t._v("如果两个模块存在循环依赖关系，并且使用了"),a("code",[t._v("@inject(SomeClass)")]),t._v("进行注释。那么在运行时，一个模块将在另一个模块之前被解析，此时装饰器会在"),a("code",[t._v("@inject(SomeClass) SomeClass还处于undefined状态")]),t._v("被调用。这时InversifyJS会抛出下面这个异常：")]),t._v(" "),a("blockquote",[a("p",[t._v("@inject called with undefined this could mean that the class ${name} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.")])]),t._v(" "),a("p",[t._v("有两种方法能够摆脱这种限制：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用"),a("code",[t._v("LazyServiceIdentifer")]),t._v("。惰性标识符并不会推迟依赖的注入，所有依赖在类实例创建时已经注入了。其实，它所推迟是对属性标识符的访问(从而解决模块问题)。这方面的示例可以从我们的"),a("a",{attrs:{href:"https://github.com/krzkaczor/InversifyJS/blob/a53bf2cbee65803b197998c1df496c3be84731d9/test/inversify.test.ts#L236-L300",target:"_blank",rel:"noopener noreferrer"}},[t._v("单元测试"),a("OutboundLink")],1),t._v("中找到。")])]),t._v(" "),a("li",[a("p",[t._v("使用"),a("code",[t._v("@lazyInject")]),t._v("装饰器。该装饰器是"),a("code",[t._v("inversify-inject-decorators")]),t._v("模块的一部分。"),a("code",[t._v("@lazyInject")]),t._v("装饰器会在依赖被实际应用前推迟其注入，该过程在类的实例被创建前发生。")])])]),t._v(" "),a("h2",{attrs:{id:"依赖关系图-类-中的循环依赖关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖关系图-类-中的循环依赖关系","aria-hidden":"true"}},[t._v("#")]),t._v(" 依赖关系图(类)中的循环依赖关系")]),t._v(" "),a("p",[t._v("InversifyJS能够识别循环依赖。如果检测到循环依赖，它会抛出一个异常来帮助你识别问题的位置:")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("Error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Circular dependency found"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Ninja "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("D")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])])}),[],!1,null,null,null);e.default=r.exports}}]);